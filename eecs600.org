#+TITLE: EECS 600 (Internet Security) Notes
#+AUTHOR: Stephen Brennan
#+SETUPFILE: config.setup

* 2016-01-28 Thursday

  Last time - firewall.  Distinguishing feature: interposed in your path to the
  network.

  Today: Intrusion Detection System.  These inspect packets, do "deep packet
  inspection", and try to correlate them together to identify attacks and
  intrusion attempts.

  - May have multiple IDS's.  For instance, you may set up a DMZ for publicly
    accessible servers, and have a IDS for them.  Then, in the private network,
    another IDS.  Finally, you may put further IDS's closer to valuable assets
    in order to improve your chances of detection.
  - Taxonomy of IDS's:
    - Signature based vs anomaly detection
      - Signature based: has classifiers for several different attack types.  If
        incoming traffic is classified as an attack, raise an alarm.
        - These can be more accurate, because they can describe specific attacks
          that may not look anomalous.
        - However, they cannot detect new attacks.
      - Anomaly detection: creates statistical models for "normal" traffic.
        Then raises an alarm when traffic "sticks out" from the normal model.
        - Can detect new attacks
        - So many false positives
    - Network IDS vs Host IDS
      - NIDS: sniff packets on a whole network.  Requires lots of computing
        power.  But, this means that they are monitoring an entire network
        segment.
      - HIDES: Analyzes only at the host-level.  Can use OS-level events (even
        TCP state tracking).  Usually deployed on high-value targets.

  Evasion
  - Searching for text or patterns within TCP connections is hard.
    - Can't look just for text in a packet (could be spread across multiple)
    - Can't look just for text in sequential packets (could be reordered)
    - Could we reassemble the byte stream?  Tricky...
  - Defining patterns to search for is hard
    - For directory names, could substitute a ton of variations on valid path
      names.
    - Or could use character escapes.
  - Packet fragmentation!
  - As an attacker, any of these variations can be combined.
  - Additionally, IDS's fail "open", such that the network traffic continues to
    flow if an IDS is overwhelmed.  So one common attack is to disable the IDS
    by volume or some other way, and then carry on your actual attack without
    detection.
  - TTL Exploit:
    - An attacker may send multiple TCP segments with the same sequence
      number, but different payloads, and different TTL fields.
    - The ones with lower TTL fields will be dropped, so the end host will
      only see their intended text.
    - But IDS will see all the different segments, and have trouble piecing
      together the true message.
  - Fragmentation Attack:
    - Overlap:
      - Send IP fragment F1 and F2, where F2 overlaps the end of F1.
      - This is "prohibited" - it should never happen.
      - But, OS's deal with it in different ways.
        - Some use the data from F1
        - Some use the data from F2
        - Some use the first packet to arrive.
      - IDS can't guess behavior of every end system
    - Reassembly:
      - Network stacks need to hold onto packets that are fragmented, so that
        when they receive the next one, they can piece them together.
      - They have a timeout on their buffers, so that they don't hold them
        indefinitely.
      - If the end host has a longer timer than the IDS:
        - Send F1, wait for the IDS to timeout, then send F2
      - If the IDS has a longer timer than the end-host:
        - Prepare fragments F1, F2, F2', such that F1F2 is an attack, but
          F1F2' looks ok.
        - Send F1
        - Wait for end-host to timeout.
        - Send F2'
        - ... (slides)

  Port Scan Evasion:
  - If a computer (Patsy) has deterministic IP IDs, an attacker can send a ping
    stream to view the IP ID state.  Then, they can send TCP SYN's to a victim,
    spoofed as the Patsy.
  - If the Victim's port is open, they will SYN ACK to the Patsy, and the PATSY
    will RESET back, which uses in IP ID.  The attacker can observe this and
    have good evidence that the port is open.

  IDS Guidelines
  - Preventing TTL attacks:
    - Deploy as close to destination hosts as possible
  - Preventing fragmentation attacks:
    - Drop fragmented packets at entry
    - Not a great solution!  What about tunneling?  Fragmentation regularly
      happens when tunneling traffic.
  - Bifurcation attacks
    - Try to analyze all possibilities.
    - Also not a good solution.

  Traffic Normalizer
  - Sit in the path of traffic, and resolves ambiguities.
  - For fragments, it will use the shortest reassembly timer, and drop the next
    packet fragments after the timeout so nobody gets them (either IDS or end
    host)
  - Always rewrite TTL to fixed value.
  - Always resolve fragment ambiguities in a particular way.
  - Limitations
    - Can't know application behavior
    - EG: TCP urgent pointer
      - Some system calls may not return "urgent" data without a special
        command.
      - So, one way you might read "robot", another way may read "root".
      - The IDS/normalizer can't know how the socket is being used, so it can't
        tell about these things.

  On the bright side, traffic normalizer fails closed, which is good for
  preventing attacks, but bad if the attacker wants to cut off internet access.

  Summary:
  - NIDS performs stateful deep packet inspection
  - Difficult - must obtain same view of traffic as the destination.
  - When IDS view diverges from hosts, problems happen
  - Normalizers can help keep these views synchronized

* 2016-01-26 Tuesday

  Today: IPSec, Firewalls.  Next time: Intrusion Detection Systems.  Next
  Tuesday: my paper discussion.  Also, be thinking about project ideas (Thu-Tue
  after my presentation).

** Virtual Private Networks

   - Institution would like to have completely separate, private network for
     security.
   - But it's expensive to geographically link multiple far apart branches, and
     it's nearly impossible (without a really big retractable cable) to connect
     roaming employees securely.
   - So, VPNs provide encrypted transfer across the internet, making things look
     like you're connected to the same network.

   Can use many technologies to create VPN:
   - IPsec
   - TLS
   - DTLS (datagram TLS = TLS for UDP)

   IPsec
   - data integrity
   - origin authentication
   - replay attack prevention
   - confidentiality
   - blanket coverage (encrypts all types of packets)
   - can use it in many different ways
     - one is at the border routers to tunnel to other places

   Security Associations (SA)
   - state information (including keys) for one direction of communication over
     IPsec. Contains:
     - IP addresses of both sides of communication
     - enryption algorithm and key
     - type of integrity check used along with authentication key (for signing)
   - Security Association Database (SAD) is used to store that state information
   - Security Policy Database (SPD) is used to determine the rules for which
     data grams are "subjected"" to IPsec, and which ones can just go on to the
     "secure" side of a IPsec gateway.

   IPsec packet structure (went over in class, wasn't really good for writing
   down).

   Summary of IPsec services: a man in the middle
   - can't see the original contents of a datagram
   - can't flip bits without detection
   - can't masquerade as either party by using their IP address
   - can't replay a datagram
   - can see the source and destination IP address

   Key Exchange??  IKE = Internet Key Exchange
   - First, Diffie-Helmann a secure channel between two people
   - Then, do authentication (could be through a variety of ways)
   - Finally, create two SA's.

** Firewalls

   Firewall: Isolates organization's internal network from larger Internet,
   allowing some packets to pass, blocking others.

   Three types:
   - Statetless
   - Stateful
   - Application gateway

   Stateless packet filtering:
   - Only makes decision based on info within the packet
     - source/destination IP address
     - IP protocol
     - source/destination port (for UDP and TCP)
     - other fields from headers
   - Examples:
     - block by port numbers to block services like Telnet
     - block TCP segments with ACK=0, to prevent external hosts from opening TCP
       connections with internal hosts
     - block incoming/outgoing DNS except from approved DNS resolver

   Stateful
   - EG, TCP connection tracking (yo.... PyWall!!!)

   Application Gateways
   - Filters packets by application data as well as their header fields
   - for example, a web filter

* 2016-01-21 Thursday

  Points from "SSL Landscape - A Thorough Analysis of the X.509 PKI Using Active
  and Passive Measurements".

  (Note I would like to discuss at end of class: revocation lists - why aren't
  they signed (to address Google's concern about revocation lists)).

  Read the paper.  The points were from there.

* 2016-01-19 Tuesday

  *Defense for DNS*
  - Close resolvers to outside queries!
    - But, WiFi routers frequently offer a "trap door" to indirectly query
      resolvers even when they're closed.
    - Some need to be open (Google public DNS)
  - Ultimate solution to DNS security: DNSSEC

** DNSSEC

   *Goals*
   - Origin Authentication: make sure that a response really came from the
     authoritative "zone"
   - Integrity: make sure that the response hasn't been changed

   *Main Ideas*
   - Each zone gets a public/private key.
   - Public key goes into a DNSKEY record.
   - Private key is used to sign records, and since records are typically
     static, ideally the private key will be kept offline.
   - Signature is stored in RRSIG record.

   *Authenticity of DNSKEY*
   - Get your key signed by your parent's ADNS.
     - When you get authority for your zone, you get your key signed.
     - Your parent ADNS keeps NS record for your ADNS.
     - They also keep a DS (Delegation Signature) record to
   - Somewhat similar to a CA hierarchy.

   *Non-Existing Name*
   - When you query for a non-existing name, you return a NXDOMAIN record.
   - How to trust that, when a man in the middle could simply capture a record
     signed once and feed it back to queries for each query?
   - You would have to sign each NXDOMAIN query individually, which would
     require an online private key.
   - Instead, we use an NSEC record, which specifies a "bracket" between
     subdomains (e.g. "a.case.edu" through "d.case.edu"), and says that there
     are no valid domains in between them.
   - All signatures expire (so that this will become invalid after a while).
   - So, an invalid query would return NXDOMAIN, plus the correct bracket around
     the invalid domain.
   - Sadly, this introduces the problem that now you can easily enumerate all
     DNS names in a zone.
   - Instead, we can hash the valid names, and order those.  We use those
     brackets instead!  NSEC3 records!

   *Chain of Trust*
   - We now have two different trust hierarchies: DNSSEC, and X.509 (that is,
     PKI, or the SSL certificate hierarchy).  (There is actually a third
     hierarchy for router advertisements, based on the hierarchy of ISP's, etc).

   *Problems*
   - Although DNSSEC solves authentication and integrity, it makes DNS
     reflection attacks worse.
     - This is because it makes responses even bigger, providing a bigger
       amplification for reflection attacks.
   - Responses are too big for UDP.
   - As a result, deployment is very low.
     - This may change if we are able to prevent forged source IP addresses.
     - Or, if a high-profile DNS poisoning attack occurs (e.g. Google).

** X.509 Overview

   Correction of TLS handshake:
   - The 5th exchange of the TLS handshake presented last time indicated that
     the server sends back a master key encrypted with the client's public key.
   - However, this would allow a hijacking!
   - Instead, each side generates some random bits, and they are exchanged in
     the first two exchanges.  Then, the client sends some bits to the server
     encrypted with the server's public key.
   - Both sides compute the master key from those bits.

   *Holz, Braun, Kammenhuber, Carle: SSL Landscape (IMC'11)*

   - Analysis of certificates in the wild.
   - Datasets:
     - Top million Alexa sites. (from 9 vantage points)
     - Third-party scan of the whole internet.
     - Passive monitoring of a research institution's 10Gb link.

   *Weaknesses of X.509*
   - Any compromised CA can sign a certificate for any domain.
     - DigiNotar attack (2011)
   - A compromised EE (end entity) can have an attacker masquerade as it.
   - If browser doesn't keep up to date with revocation, etc, or if it doesn't
     validate at all, they can connect to fraudulent sites.
   - If users ignore warnings, they can get screwed too.

* 2016-01-14 Thursday

** Encryption: Message Authentication Problem

   As we saw last time, if I want to send an encrypted message to Misha, I can
   probably easily find a private key associated with him.  However, I have no
   way of being certain that the private key I find belongs to him.  Someone
   could have maliciously crafted that key so that they could intercept my
   encrypted messages to him.

   One solution to this is to enlist a third-party to help.  If we all trust
   this third party, then I can send my public key to them, have them sign it
   (encrypt the hash with their private key), and then include that signature
   with my key when I send it to Misha.  Misha could verify the signature, and
   if he trusts the third party, he can be certain that the certificate belongs
   to me.

   This third party is called a Root Certificate Authority.  These third parties
   can, as they sign a public key, delegate the CA power to other entities,
   giving them the power to sign keys for themselves.  This creates a trust
   hierarchy.  We also have revocation lists for certificates that should no
   longer be trusted.

** HTTPS

   HTTP:
   - No privacy
   - No authentication
   - No message integrity
   - Vulnerable to hijacking

   Need a way to improve this situation.  Enter HTTPS!  HTTPS = HTTP over
   TLS. HTTPS Connection startup:
   - Client \to Server: opens connection with Server
   - Server \to Client: responds with signed certificate and session ID
   - Client \to Server: sends some bits (encrypted with Server's public key), also
     sends their public key
   - Server \to Client: adds their own bits, generates a random master key, and
     sends that back, encrypted with client public key
   - Client \to Server: encrypts with the master key a hash of all messages sent
     previously, guaranteeing they were the one the server was talking to all
     along.

   HTTP Benefits;
   - Authentication - somewhat.  If we can trust our third parties in the
     certificate authority hierarchy, we can generally trust for authentication.
   - Privacy - encrypted communication means people can't listen in after the
     initial negotiation

** DNS

   Negative Response Rewriting
   - When you do a DNS query with your local DNS resolver (typically operated by
     an ISP), and the result is an error (failure), the resolver may rewrite the
     error message with their own message.
   - ISP responds with a record pointing to a "buy this domain?" page or a
     "search" page for you.  How helpful! :(
   - My ISP (time warner cable) does this >:(

   Search Engine Hijacking
   - ISP redirects www.google.com to their own servers, which communicate with
     google for searches, but modify the results, advertise, etc.
   - Not widespread anymore, because ISPs were caught doing it.

   Kaminsky Attack
   - What if DNS resolver is honest?  Well, it can still be subverted.
   - An attacker can send queries to DNS servers for random subdomains of
     existing domains.
   - Then, it can spoof the Authoritative DNS server of that domain, and send
     back a response that includes a NS record assigning the new nameserver to
     be the attacker's.
   - If the resolver accepts the fake NS record, its cache is polluted, and
     everyone who uses that resolver gets records resolved by a fake ADNS
     server.
   - Kaminsky showed that, even with 16-bit transaction identifiers, it is only
     a matter of minutes before the attacker can correctly guess the txid and
     poison a cache.  Which is not a bad cost at all if you can poison a cache
     for a long time.
   - However, if DNS resolver uses ephemeral ports for receiving the response,
     that adds 16 bits more entropy, which makes the attach pretty much
     impossible.

   Preplay attack
   - DNS resolvers on home routers can be pretty dumb.
   - Some don't check for the IP address of the RDNS, or the transaction ID, or
     the destination port!
   - So, the attacker can simply send a request and then an answer, no guessing
     required, and poison that household's DNS cache.

   You can also use the WiFi DNS forwarders to conduct Kaminsky attacks on ISP
   DNS servers that don't accept external queries.  So that's a downer.  The
   number of open forwarders has been declining (was 30 million, now is 17
   million), but still isn't great.

* 2016-01-12 Tuesday

** Logistics

  Goals:
  - Many subfields of networking are fleeting, but a few like Security and
    Measurements are long-term.  So the topic of Security is a prudent one to
    study.
  - We will prepare for research in this area by reading papers, presenting
    them, and undertaking a research project.
  - This is not computer security:
    - We will not study buffer overflows, Sql injection, etc.  Nothing that
      allows someone to take over a computer.
    - Instead, we will cover attacks that don't require compromising the
      computer, just the network.

  I'm sure topics will be available online, and we'll get to them soon enough.

  Tasks:
  - Read papers, write summaries (which "isn't as easy as you think").
  - Present a paper and lead the discussion on it.
  - Final exam = project + presentation

  Paper Summaries:
  - Topic
    - 1-2 sentence summary of the topic.
    - Is it a "mechanisms" or "characterizations" paper?
      - Mechanisms: proposes some new technique
      - Characterizations: measures some property of the internet
      - Sometimes it's both
  - Key Ideas/Observations
    - 1-2 most important ideas
    - For mechanisms, the ideas behind the mechanisms
    - For characterizations, the key observations.
  - Flaws (1 or 2)
  - Open Questions (1 or 2)
    - Where can you take the research from here?
  - My Impressions
    - 1-2 sentences with your impression (is it good or not, why?)

  Your summaries must follow these sections exactly.  Some may be absent, but
  everything must have a section.  Due before class so we can discuss (submitted
  online via email in plain text).  Note that this is mostly a summary!  Your
  opinions on the paper only belong in the small "My Impressions" section.

   Some questions to ask about the paper, to identify flaws.

   - Can someone else replicate the results using the paper?
   - Are the assumptions clear enough?  (Careful, we're not assessing, just
     learning).  Do the assumptions potentially bias the paper?
   - Does the research eliminate alternative explanations of results?
   - Do conclusions follow logically from evidence.

   Dos and don'ts in paper summaries:

   - Not a review.
   - Inappropriate characterizations are "comprehensive", or "insufficient
     references".
   - This is what you need to remember 10 years from now.
   - Value conciseness.
   - Value specificity: focus on "how", not "what"

   Discussion guidelines:

   - Lecture for about 30-40 minutes.
     - Allocate 2 minutes per slide.  You expect they will be quicker, but
       usually your explanations.
   - Discussion for 30-40 minutes
   - Wrap up (5 mins)

   Grading:
   - 20% paper presentation.
   - 40% paper summaries
   - 10% class participation (attendance + discussions)
   - 30% final

   Office hours 2:40-3:40 Thursday, or by appointment.  Prefix email subject
   lines with "eecs600".

** Encryption and Authentication

   This content will be a brief overview of the basics.  Just enough for our
   subsequent discussions on security.

   Two varieties of encryption: symmetric and asymmetric

*** Symmetric encryption:
   - Two parties share a secret.
   - Encryption/decryption algorithms scramble/unscramble plaintext using the
     key.
   - Typically very fast, and the key is very small.
   - However, it is very difficult to distribute keys securely.

   Diffie-Hellman's protocol:

   1. Alice and Bob agree to use a prime number p and a base g (which have some
      properties we won't discuss).
   2. Alice chooses secret integer a, then sends Bob \(A = g^a \mod p\).  It
      turns out that it's very difficult to guess a from A.
   3. Bob chooses secret integer b, then sends Alice \(B = g^b \mod p\).
   4. Alice computes \(s = B^a \mod p = g^{ba} \mod p\)
   5. Bob computes \(s = A^b \mod p = g^{ab} \mod p\).
   6. Alice and Bob now share the secret \(s\).

   Invented in 1976!!

*** Asymmetric encryption

    - Pair of keys, (S,P).  You encrypt with one and decrypt with the other.
    - With asymmetric encryption, the key exchange is very similar.  We make one
      of our keys public, and we simply encrypt messages to others using their
      public keys.

    Two types of asymmetric key types:
    - RSA
      - Large (1-4 kbits)
      - Efficient
    - Elliptic curve
      - Small (about 160 bits)
      - Expensive

*** Uses of Encryption

    - Message Encryption - make it so that only owners of a key can read it.
    - Message Signature
      - Message may be distributed in the clear.
      - Only the key owner could have signed it.
      - Verifies authenticity and that the message has not been modified.

    Authentication (signing) using symmetric keys.

    1. Append the key to the message.
    2. Hash that to get a "message authentication code", and append that to your
       original message, and send it.
    3. Recipient can duplicate your actions and verify the message.

    Message Authentication using asymmetric keys

    1. Hash the message, and encrypt it with your private key.  Include that as
       the signature.
    2. Recipient can decrypt your signature using the public key, hash the
       message, and compare the two hashes.

    Interesting side note: the signature will necessarily be the same size as
    the asymmetric key, which is inconvenient for large keys.

    Sadly, with asymmetric keys, it's difficult to be certain that a key belongs
    to somebody (and isn't being spoofed).  So you need to get keys certified by
    a trusted third party.
