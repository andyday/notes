<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2015-11-23 Mon 16:26 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>PHIL 201 Notes</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Stephen Brennan" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="http://orgmode.org/mathjax/MathJax.js"></script>
</head>
<body>
<div id="content">
<h1 class="title">PHIL 201 Notes</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. 2015-08-24 Monday</a></li>
<li><a href="#orgheadline3">2. 2015-08-26 Wednesday</a>
<ul>
<li><a href="#orgheadline2">2.1. Chapter 1 - Deductive Logic</a></li>
</ul>
</li>
<li><a href="#orgheadline5">3. 2015-08-28 Friday</a>
<ul>
<li><a href="#orgheadline4">3.1. Chapter 2</a></li>
</ul>
</li>
<li><a href="#orgheadline6">4. 2015-08-31 Monday</a></li>
<li><a href="#orgheadline7">5. 2015-09-02 Wednesday</a></li>
<li><a href="#orgheadline8">6. 2015-09-04 Friday</a></li>
<li><a href="#orgheadline9">7. 2015-09-07 Monday</a></li>
<li><a href="#orgheadline10">8. 2015-09-09 Wednesday</a></li>
<li><a href="#orgheadline11">9. 2015-09-11 Friday</a></li>
<li><a href="#orgheadline12">10. 2015-09-13 Monday</a></li>
<li><a href="#orgheadline13">11. 2015-09-15 Wednesday</a></li>
<li><a href="#orgheadline14">12. 2015-09-25 Friday</a></li>
<li><a href="#orgheadline19">13. 2015-10-12 Monday</a>
<ul>
<li><a href="#orgheadline15">13.1. Soundness</a></li>
<li><a href="#orgheadline16">13.2. Completeness</a></li>
<li><a href="#orgheadline17">13.3. Effectiveness</a></li>
<li><a href="#orgheadline18">13.4. Condensed Concepts</a></li>
</ul>
</li>
<li><a href="#orgheadline20">14. 2015-11-09 Monday</a></li>
<li><a href="#orgheadline21">15. 2015-11-11 Wednesday</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> 2015-08-24 Monday</h2>
<div class="outline-text-2" id="text-1">
<p>
Context:
</p>

<ul class="org-ul">
<li>Socrates - dies 399 BC</li>
<li>Plato - writes 15 years after that</li>
<li>Aristotle - even younger than that</li>
</ul>

<p>
What did Socrates write?  We know because of comedies written about him, and
ideas attributed here.  He would say he couldn't teach you anything, only talk
about stuff.  He talked about the "good life, not a teacher."  He was the
enemy of the "sophist," who takes money for teaching.
</p>

<p>
What did Plato do?  Dialogues about Socrates, and other stuff.  People copied
his works for 1500 years, so we have crystal clear knowledge of what he did.
He also ran the Academy in Athens (where the "right people"&#x2013;young men&#x2013;could
get together and learn).  He coined the term Academy in Greek.  He wrote about
"The Good".
</p>

<p>
Aristotle went to Plato's Academy.  He created Formal Logic, all by himself.
Here's some of his stuff.
</p>

<ul class="org-ul">
<li>All Greeks are mortal.  Socrates is a greek.  Therefore, Socrates is mortal.</li>
<li>Some snakes are poisonous.  There's a snake right next to your shoe.
Therefore, you should move away slowly.</li>
</ul>

<p>
Differences between the two:
</p>

<ul class="org-ul">
<li>The first is a "Universal" and the second is a "Particular" (all/some).</li>
<li>The first is "deductively valid".  That means that every argument of this
form is valid, so long as each of the propositions are true.</li>
</ul>

<p>
Modern logic came about because of von Neuman, Alonzo Church, and Alan Turing.
The same guys who created computers.
</p>

<p>
This class is about new ways of organizing arguments, not new and clever
arguments.  We will also learn how to evaluate arguments:
</p>

<ul class="org-ul">
<li>Soundness: no false positives.  A sound method could be as simple as never
answering.</li>
<li>Completeness: all correct positives.  A complete method would always say
yes.</li>
<li>Effective: always gives you an answer.</li>
</ul>

<p>
This logic is:
</p>

<ol class="org-ol">
<li>Utterly precise</li>
<li>Artificial</li>
<li>Simple (but not necessarily easy)</li>
<li>Limited</li>
</ol>

<p>
The textbook: "The Logic Book" by Merrie Bergman.
</p>
</div>
</div>
<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3"><span class="section-number-2">2</span> 2015-08-26 Wednesday</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2"><span class="section-number-3">2.1</span> Chapter 1 - Deductive Logic</h3>
<div class="outline-text-3" id="text-2-1">
<p>
"There is no inductive logic."
</p>

<p>
A <b>sentence</b> is a statement which is True or False.  What is <i>not</i> a sentence
in our terminology?
</p>
<ul class="org-ul">
<li>Interrogatives (questions)</li>
<li>Imperatives (commands)</li>
<li>(<i>Future tense, predictions</i>) - in logic class, these are true or false,
but there could be lots of lively debate.  Apparently Aristotle wrote about
this and our instructor says it is a "long and confusing" section.</li>
<li>Opinionated statements (e.g. "France is a beautiful country.").  For logic
textbook purposes, we can treet these as declarative sentences, but we
don't typically think of them that way in the real world.</li>
</ul>

<p>
An <b>argument</b> is a list of sentences, one of which is called a <b>conclusion</b>,
the others are called <b>premises</b>.  There can be discussion about how many
sentences are required, but really you only need one to have an argument.
Additionally, the book says in older editions that the premises should be
"intended to support the conclusion."  But that really shouldn't matter.
This is missing several parts from normal definitions of arguments:
</p>
<ul class="org-ul">
<li>Opposing viewpoints.</li>
<li>Reasoning (why a premise supports a conclusion).</li>
</ul>

<p>
A (Deductively) <b>valid</b> argument is an argument where there is no way for the
premises to be True while the conclusion is False.  Correspondingly, an
<b>invalid</b> argument is one where there is some way for the premises to be True
and the conclusion False (which is called a <b>counterexmple</b>, CE).
</p>

<p>
Example Arguments:
</p>

<ul class="org-ul">
<li>Today is Wednesday and is not Wednesday.  &there4;, the temperature is 80&deg;F.
<ul class="org-ul">
<li>Valid.  The premise is never true.  There is no way for the premise to be
true while the conclusion is false.  <b>An argument with inconsistent
premises is trivially valid.</b></li>
</ul></li>
<li>Columbus is capital of Ohio.  &there4; Columbus is in Ohio.
<ul class="org-ul">
<li>Doesn't matter.  This is where the "no way" becomes vague.</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5"><span class="section-number-2">3</span> 2015-08-28 Friday</h2>
<div class="outline-text-2" id="text-3">
<p>
Sentences \(p\) and \(q\) are <b>logically equivalent</b> if there is no way to make
one True and the other False.
</p>

<p>
EG:
</p>
<ul class="org-ul">
<li>It is either not Wednesday or not raining.  (or both)</li>
<li>It is not Wednesday and raining.</li>
<li>(FYI, DeMorgan's Law)</li>
</ul>

<p>
Quiz on Wednesday.  What will be on the quiz?  Definitions mostly.
Definitions we covered up till the quiz.  Which may include chapter 2.
</p>

<p>
A list of sentences is <b>consistent</b> if there is Some Way for all to be True at
once.  Satisfiability!!  EG:
</p>

<ul class="org-ul">
<li>If today is Wednesday, then it's not raining.</li>
<li>Today is Wednesday.</li>
<li>It is raining.</li>
</ul>

<p>
No matter how you did it, you couldn't make all of these true.  So this list
of sentences is not consistent.
</p>

<p>
P<sub>1</sub>, P<sub>2</sub>, &#x2026;, P<sub>n</sub> &there4; C is Logically Valid iff the list {P<sub>1</sub>, P<sub>2</sub>, &#x2026;, P<sub>n</sub>,
&not;C} is inconsistent.
</p>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">3.1</span> Chapter 2</h3>
<div class="outline-text-3" id="text-3-1">
<p>
An <b>atomic</b> sentence is a sentence with no smaller sentence as part.  A
<b>connective</b> is a word (or words) that applies to one or more sentences to
form a sentence.  EG:
</p>
<ul class="org-ul">
<li>"not" - applies to any sentence, and creates a new sentence.</li>
<li>"and" - can go between sentences, and creates a new one</li>
<li>"don't say" - is NOT a connective, because it forms an imperative, not a
sentence.</li>
<li>"I don't believe" - is a connective.</li>
</ul>

<p>
A <b>Truth Functional Connective</b> is a connective such that the truth value of
the sentence it forms is wholly determined by the truth value of the parts.
</p>

<ul class="org-ul">
<li>NOT + (Bornite is a Cu ore): this is TFC, because Not always reverses the
truth value.</li>
<li>My Brother Knows + (Bornite is a Cu ore): this is a connective, but not
TFC, because the sentence alone doesn't tell you whether the whole thing is
true.</li>
</ul>

<p>
In other words, TFCs are connectives that have truth tables!!!  EG, for not:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">P</td>
<td class="org-left">&not;P</td>
</tr>

<tr>
<td class="org-left">T</td>
<td class="org-left">F</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">T</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6"><span class="section-number-2">4</span> 2015-08-31 Monday</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>A = it is raining</li>
<li>B = it is wednesday</li>
<li>&not;B = not - it is raining</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-left">B</td>
<td class="org-left">&not;A</td>
<td class="org-left">&not;&not;A</td>
<td class="org-left">A&and;B</td>
<td class="org-left">A&or;B</td>
<td class="org-left">A&rarr;B</td>
<td class="org-left">A&equiv;B</td>
</tr>

<tr>
<td class="org-left">T</td>
<td class="org-left">T</td>
<td class="org-left">F</td>
<td class="org-left">T</td>
<td class="org-left">T</td>
<td class="org-left">T</td>
<td class="org-left">T</td>
<td class="org-left">T</td>
</tr>

<tr>
<td class="org-left">T</td>
<td class="org-left">F</td>
<td class="org-left">F</td>
<td class="org-left">T</td>
<td class="org-left">F</td>
<td class="org-left">T</td>
<td class="org-left">F</td>
<td class="org-left">F</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">T</td>
<td class="org-left">T</td>
<td class="org-left">F</td>
<td class="org-left">F</td>
<td class="org-left">T</td>
<td class="org-left">T</td>
<td class="org-left">F</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">F</td>
<td class="org-left">T</td>
<td class="org-left">F</td>
<td class="org-left">F</td>
<td class="org-left">F</td>
<td class="org-left">T</td>
<td class="org-left">T</td>
</tr>
</tbody>
</table>

<p>
In "King George's English", you may repeat "not" several times to emphasize
just how much "not" you mean.  EG "I will not not not not not go to class!".
Also, in English, "or" can mean "one or the other, but not both" (exclusive
or).  It can also mean "one or the other or both" (inclusive or).  The only
way you can tell is by context.  In logic, we define or to be inclusive, when
we use the &or; symbol.
</p>

<p>
For if/then, we say A &rarr; B, where A is the <b>antecedent</b>, and B is the
<b>consequent</b>.  If has a lot of meanings in English, but in logic, we use
implication.  It's like a promise.  When you tell your friend "if I finish the
paper, then I'll come over to your place", the only thing that would offend
them is if you finished the paper, but did not come over.  Any other situation
is pretty much fine.
</p>

<p>
He says to use plus for exclusive or (if you ever use it), but I prefer &oplus;.
And we don't really use exclusive or.
</p>

<ul class="org-ul">
<li>Tomorrow will Rain unless it Snows
<ul class="org-ul">
<li>This is R &or; S.</li>
<li>Unless &equiv; Or</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7"><span class="section-number-2">5</span> 2015-09-02 Wednesday</h2>
<div class="outline-text-2" id="text-5">
<p>
Quiz.
</p>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8"><span class="section-number-2">6</span> 2015-09-04 Friday</h2>
<div class="outline-text-2" id="text-6">
<p>
No class, professor absent.
</p>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-2">
<h2 id="orgheadline9"><span class="section-number-2">7</span> 2015-09-07 Monday</h2>
<div class="outline-text-2" id="text-7">
<p>
No class, labor day.
</p>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-2">
<h2 id="orgheadline10"><span class="section-number-2">8</span> 2015-09-09 Wednesday</h2>
<div class="outline-text-2" id="text-8">
<p>
I skipped.  We went over the quiz.
</p>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-2">
<h2 id="orgheadline11"><span class="section-number-2">9</span> 2015-09-11 Friday</h2>
<div class="outline-text-2" id="text-9">
<p>
John will sing and Don dance unless Alice reads.
</p>
<ul class="org-ul">
<li>Sentential logic: J &amp; D &or; A.  But which?
<ul class="org-ul">
<li>(J &amp; D) &or; A</li>
<li>J &amp; (D &or; A)</li>
<li>They are both valid, and different.</li>
<li>To see this, let J=F, D=T, A=T.  The first one is True, and the second is
False.</li>
<li>Now we're getting side tracked on unless, vs logical implication, etc.</li>
<li>Unless = inclusive or.  We get it.  Really.  Please stop.</li>
</ul></li>
<li>You need to rely on the grammar of the sentence.  "Don dance" depends on
"John will sing" for a verb, so you would expect that those two are closer
than the Alice part.</li>
<li>In general, showing your work (e.g. by parenthesizing the original
sentence), leads to partial credit, but more commonly, it just leads to
getting the answer correct more frequently.</li>
</ul>

<p>
If I buy Apples then if I get Bananas I'll get Cherries.
</p>
<ul class="org-ul">
<li>A &rarr; (B &rarr; C)</li>
<li>Or is it (A &rarr; B) &rarr; C?</li>
<li>You can tell that they're different because the first is T when A=T, and you
can make the second false by then making B=T and C=F.</li>
<li>It's easy to resolve this one.</li>
</ul>

<p>
If I buy Apples and Bananas, then I'll buy Cherries.
</p>
<ul class="org-ul">
<li>(A &amp; B) &rarr; C</li>
</ul>

<p>
Are those last two sentences the same?
</p>
<ul class="org-ul">
<li>~(A &amp; B) &or; C</li>
<li>~A &or; ~B &or; C</li>
<li>~A &or; (B &rarr; C)</li>
<li>A &rarr; (B &rarr; C)</li>
<li>Yaas!</li>
<li>Or you could do</li>
</ul>

<p>
Al dislikes bananas, passionately.  Al detests bananas.
</p>
<ul class="org-ul">
<li>Are they equivalent?</li>
<li>Ch. 1: maaaybe?</li>
<li>Ch. 2: no.  A &equiv; B!!</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline12" class="outline-2">
<h2 id="orgheadline12"><span class="section-number-2">10</span> 2015-09-13 Monday</h2>
<div class="outline-text-2" id="text-10">
<p>
I missed.
</p>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-2">
<h2 id="orgheadline13"><span class="section-number-2">11</span> 2015-09-15 Wednesday</h2>
<div class="outline-text-2" id="text-11">
<p>
~(A&amp;B), ~(B&amp;C), &there4; ~A &rarr; C
</p>

<p>
Not a valid argument.  A, B, and C could all be false.  Then, you have both
premises true, but the conclusion is false.
</p>

<p>
They're talking about a "tree" method.  I missed that.  So he's going to do a
tree here.  I'll take notes.
</p>

<p>
Set of sentences (not argument, we negated conclusion).
</p>
<ul class="org-ul">
<li>~(A&amp;B)</li>
<li>~(B&amp;C)</li>
<li>~(~A&rarr;C)</li>
</ul>

<p>
Now we try to satisfy all 3 with an tree.
</p>
<ul class="org-ul">
<li>~A will make ~(A&amp;B) true
<ul class="org-ul">
<li>~B will make ~(B&amp;C) true
<ul class="org-ul">
<li>~A and ~C will make ~(~A&rarr;C) true</li>
</ul></li>
<li>~C will make ~(B&amp;C) true
<ul class="org-ul">
<li>~A and ~C will make ~(~A&rarr;C) true</li>
</ul></li>
</ul></li>
<li>~B will make ~(A&amp;B) true
<ul class="org-ul">
<li>No need to go further.</li>
</ul></li>
</ul>

<p>
We can see that in the first branch, we have ~A, ~B, ~C as a way to make all
sentences true.  Which means it's a counterexample.  Yay.
</p>

<p>
(A &rarr; (B &amp; C)) &rarr; (A &rarr; C)
</p>

<p>
Is it true?
</p>

<p>
We can try to make the opposite true.
</p>

<p>
~((A &rarr; (B &amp; C)) &rarr; (A &rarr; C))
</p>

<ul class="org-ul">
<li>To make the not true, we make the inside false.
<ul class="org-ul">
<li>To make the inside false, we make the antecedent true and the consequent
false.  That is, (A &rarr; (B &amp; C)) and (A &rarr; C).
<ul class="org-ul">
<li>Not sure where we go from here.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14"><span class="section-number-2">12</span> 2015-09-25 Friday</h2>
<div class="outline-text-2" id="text-12">
<p>
There are logic sentences on the board.
</p>

<ul class="org-ul">
<li>\((A \lor B) \to C\)</li>
<li>\(D \to E\)</li>
<li>\(E \to B\)</li>
<li>&there4; ~C &rarr; ~D (negate to ~(~C&rarr;~D))</li>

<li>(A &or; B) &rarr; C
<ul class="org-ul">
<li>~(A &or; B)
<ul class="org-ul">
<li>~A, ~B.  Now, D &rarr; E
<ul class="org-ul">
<li>~D: E &rarr; B
<ul class="org-ul">
<li>~E : ~(~C &rarr; ~D)
<ul class="org-ul">
<li>~C, D: FALSE</li>
</ul></li>
<li>B : ~(~C &rarr; ~D)
<ul class="org-ul">
<li>~C, D: FALSE</li>
</ul></li>
</ul></li>
<li>E: E &rarr; B
<ul class="org-ul">
<li>~E: FALSE</li>
<li>B: FALSE</li>
</ul></li>
</ul></li>
</ul></li>
<li>C: Now, D &rarr; E
<ul class="org-ul">
<li>more stuff</li>
</ul></li>
</ul></li>

<li>Should start with the tree that doesn't branch.</li>
<li>Then go to sentences that look like they'll have conflicts.</li>

<li>A &rarr; (B &or; C)</li>
<li>B &rarr; (D &amp; E)</li>
<li>~(A &rarr; D)</li>

<li>A, ~D: go to A &rarr; (B &or; C)
<ul class="org-ul">
<li>~A FALSE</li>
<li>B &or; C
<ul class="org-ul">
<li>B: B &rarr; (D &amp; E)
<ul class="org-ul">
<li>~B FALSE</li>
<li>D &amp; E
<ul class="org-ul">
<li>D, E: FALSE (~D)</li>
</ul></li>
</ul></li>
<li>C: B &rarr; (D &amp; E)
<ul class="org-ul">
<li>~B: TRUE</li>
<li>D &amp; E</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>
Set A, ~B, C, ~D
</p>

<p>
A &equiv; (B &or; C)
C &equiv; (A &amp; ~B)
</p>

<ul class="org-ul">
<li>A, (B &or; C)
<ul class="org-ul">
<li>B: C &equiv; (A &amp; ~B)
<ul class="org-ul">
<li>C, (A &amp; ~B)
<ul class="org-ul">
<li>A, ~B: FALSE</li>
</ul></li>
<li>~C, ~(A &amp; ~B)
<ul class="org-ul">
<li>~A, B: FALSE</li>
</ul></li>
</ul></li>
<li>C:
<ul class="org-ul">
<li>C, (A &amp; ~B)
<ul class="org-ul">
<li>A, ~B: TRUE</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>
Set A, C, ~B
</p>
</div>
</div>
<div id="outline-container-orgheadline19" class="outline-2">
<h2 id="orgheadline19"><span class="section-number-2">13</span> 2015-10-12 Monday</h2>
<div class="outline-text-2" id="text-13">
<p>
These aren't actually my notes for today's class.  There's a quiz in class
today, so I'm using today's notes as a place to take notes on the content of
the past week.  We have three major topics: soundness, completeness, and
effectiveness.  Particularly, we've been talking about these properties of the
Tree Method for Validity in Sentential Logic.
</p>
</div>

<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15"><span class="section-number-3">13.1</span> Soundness</h3>
<div class="outline-text-3" id="text-13-1">
<p>
The soundness property of any method means that it will never produce false
positives.  If a method says "this argument is valid", then the argument
<i>must</i> be valid.  The simplest sound test is to say no argument is valid.  In
Machine Learning terms, a sound argument (classifier) is one that produces no
false positives, and thus has perfect Precision.
</p>

<p>
More formally, you can state soundness as "if the method says an argument is
valid, then the argument is valid".  We can prove this by proving the
contrapositive, that is: "if the argument is invalid, then the method will
not say it is valid".
</p>

<ul class="org-ul">
<li>To say an argument is invalid is to say that there is a counterexample
(i.e. a row in a truth table that makes the whole list true).</li>
<li><p>
First, we prove the lemma: "if a row of the truth table makes a sentence
valid, then that same row will make at least one of the branches true."
</p>
<ul class="org-ul">
<li>For atomic or negated atomics, there is no branch.</li>
<li>For conjunctions \(A \land B\), the only row that could make the conjunction
true is assigning True to both \(A\) and \(B\).  The tree rule will create
one branch with \(A\) and \(B\) on it.  The only table row that makes \(A \land
       B\) true also makes both \(A\) and \(B\) true in the subsequent rule.</li>
<li>For negated conjunctions \(~(P \land Q)\), The rule will expand to two trees:
one that is \(~P\), and the other that is \(~Q\).  The rows that could make
\(~(P \land Q)\) true are:
<ul class="org-ul">
<li>\(~P\), \(~Q\): this makes both \(~P\) and \(~Q\) branches true.</li>
<li>\(~P\), \(Q\): this makes the \(~P\) branch true</li>
<li>\(P\), \(~Q\): this makes the \(~Q\) branch true.</li>
</ul></li>
<li>For \(P \lor Q\), the rule will expand to two branches: one with \(P\), the
other with \(Q\).  The truth table rules that make \(P \lor Q\) true are:
<ul class="org-ul">
<li>\(P\), \(Q\): this makes both branches true</li>
<li>\(P\), \(~Q\): this makes the \(P\) branch true</li>
<li>\(~P\), \(Q\): this makes the \(Q\) branch true</li>
</ul></li>
</ul>
<p>
We can keep doing this for every tree rule (which kinda stinks, but we'll
have to know how to do this for any tree rule he gives us).
</p></li>
<li>The second part of the proof is pretty simple.  You need to prove the
statement that "if some row of the truth table makes all the sentences on a
current branch true, then applying any truth tree rule to a sentence on
that branch will result in at least one branch remaining open":
<ul class="org-ul">
<li>This is a direct result of the previous lemma.</li>
<li>Choose any sentence and any rule, and apply the rule to the sentence.</li>
<li>If the rule makes no branches at all, then the subtree will be a tree
with one less sentence, and the same branch still makes all those
sentences true.  So the branch is still open.</li>
<li>If the rule makes any branches, then applying the above lemma, since
there is truth tree row that makes this sentence true, that row also
makes at least one of the child branches true.  That row also makes the
remaining sentences in the tree true, so that (those) child branch(es)
remain open.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16"><span class="section-number-3">13.2</span> Completeness</h3>
<div class="outline-text-3" id="text-13-2">
<p>
As soundness is the property of "no false positives", completeness is the
property of "no false negatives".  This means perfect Recall.  More formally,
if an argument is valid, then the method will say it is valid (i.e. the truth
tree will close).  To prove this, we prove the contrapositive: "if the method
does not say it is valid, then the argument is invalid".  We'll rely on
effectiveness in this proof, but I guess the proof of effectiveness isn't
content for this quiz.
</p>

<p>
Since every tree will eventually complete (in SL&#x2026;), all we need to do is
say that every open branch on a completed truth tree corresponds to a (not
necessarily unique) counterexample.
</p>

<p>
To show this, we consider a finished open branch on a tree.  Go up it,
assigning T to each atomic sentence you see.  Once you're done, assign F to
every atomic that you didn't see (just so that you have a decision made for
every variable).
</p>

<p>
The first thing to say is that you are guaranteed that you will get a
consistent variable assignment.  This is because if you got a contradictory
variable assignment, this branch would be closed (that's the condition for
closing a branch!).
</p>

<p>
The second thing is to show that this variable assignment makes every
sentence in the tree True.  We do this as we go up the tree, for each kind of
rule.  This is actually a bit inductive - the first case is the base case,
and the following cases seem to require the inductive hypothesis.
</p>

<ul class="org-ul">
<li>An atomic/negated atomic sentence can't be False, because we are assigning
it to true.</li>
<li>Conjunctions \(P \land Q\) can't be the first sentence to be made false, since
the tree below has made both P and Q to be true (the inductive
hypothesis).</li>
<li>Negated conjunctions \(~(P \land Q)\) can't be the first sentence to be made
false, since below it either \(~P\) or \(~Q\) was true (it could be both, but
we only know that one of them is true).  If we've made one of those true,
then we've made this sentence true as well.</li>
<li>For \(P \lor Q\), they can't be the first sentence made false.  This is
because below, we've either got \(P\) or \(Q\) to be true.  It could be both,
but we know that at least one of them is true).  By the definition of \(\lor\),
this means that \(P \lor Q\) must also be true.</li>
<li>This continues for every rule.</li>
</ul>

<p>
This tells you that every open branch must produce a variable assignment, and
since all the sentences are true, thet variable assignment is a
counterexample.  Therefore, whenever the tree finishes with an open branch,
there is a counterexample, and so there are no false negatives.
</p>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17"><span class="section-number-3">13.3</span> Effectiveness</h3>
<div class="outline-text-3" id="text-13-3">
<p>
It seems silly that this proof won't be quizzed on, but whatever.
Essentially, you look at any collection of sentences and see that you can
place an upper bound on the number of tree levels that are necessary to rid
it of all its binary connectives and negations.  You just need to show that
for each binary connective tree rule, you get on the next level one less
binary connective, and at most one more negation.
</p>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-3">
<h3 id="orgheadline18"><span class="section-number-3">13.4</span> Condensed Concepts</h3>
<div class="outline-text-3" id="text-13-4">
<p>
<b>Soundness:</b>
</p>
<ul class="org-ul">
<li>"No false positives"</li>
<li>If Tree says it's valid, then argument is valid.</li>
<li>If invalid, then tree says invalid.</li>
<li>If counterexample, then tree finds it.</li>
<li>If a row makes all sentences true, then there will be an open branch.</li>
<li>Must show: for each rule, every row that makes it true makes one of the
children true.</li>
</ul>

<p>
<b>Completeness:</b>
</p>
<ul class="org-ul">
<li>"Every correct positive."
<ul class="org-ul">
<li>If argument is valid, then tree says it's valid.</li>
</ul></li>
<li>"No false negatives."
<ul class="org-ul">
<li>If tree says it's invalid, then argument is invalid.</li>
</ul></li>
<li>Both of the above "statements" followed by formal statements are
equivalent; we use the second.</li>
<li>Every open tree branch corresponds to a counterexample.</li>
<li>Must show: for each rule, if one of its children is true, then the parent
is also true.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline20" class="outline-2">
<h2 id="orgheadline20"><span class="section-number-2">14</span> 2015-11-09 Monday</h2>
<div class="outline-text-2" id="text-14">
<p>
Review day before FOL quiz!  Let's get ready to rumble.
</p>

<p>
A counter example in FOL is a universe of discourse, and probably some other.
</p>

<p>
Here is a premise and conclusion:
</p>
<ul class="org-ul">
<li>\(\forall x \exists y Wxy\)</li>
<li>\(\exists x \forall y Wyx\)</li>
</ul>

<p>
Or the list:
</p>
<ul class="org-ul">
<li>\(\forall x \exists y Wxy\)</li>
<li>\(~\exists x \forall y Wyx\), which is \(\forall x ~\forall y Wyx\).</li>
</ul>

<p>
To do the tree:
</p>
<ol class="org-ol">
<li>Since there's no way to get a constant, create \(a\) substituted for \(x\).</li>
<li>Now we have:
<ul class="org-ul">
<li>\(\exists y Way\)</li>
<li>\(~\forall y Wya\)</li>
</ul></li>
<li>Now, we create \(b\) substituted for \(y\) in the first one:
<ul class="org-ul">
<li>\(Wab\)</li>
<li>\(\exists y ~Wya\)</li>
</ul></li>
</ol>

<p>
I got a bit lost in this tree stuff.  But here is the counter example, in a
way that I believe he'd like it on the quiz:
</p>

<ul class="org-ul">
<li>\(UD = \{0,1\}\)
<ul class="org-ul">
<li>\(a\) is a name for 0</li>
<li>\(b\) is a name for 1</li>
</ul></li>
<li>\(W: \{<0,1>, <1,0>\}\)</li>
</ul>

<p>
Or you could also use \(W: \{<0,0>, <1,1>\}\).
</p>

<p>
Translations?
</p>

<p>
"Nobody wrote to everyone taller than them."
</p>

<ul class="org-ul">
<li>~ &exist; x (&forall; y (Tyx &rarr; Wxy))</li>
<li>Here, Tyx means y is taller than x.</li>
<li>And, Wxy means x wrote to y.</li>
<li>It appears that he'd like us to go quantifier by quantifier, substituting a
new sentence inside so that we can show how we went.  For the above:</li>
<li>Nobody wrote to everyone taller than them.</li>
<li>~ &exist; x (x wrote to everyone taller than them)</li>
<li>~ &exist; x (&forall; y (if y is taller than x, then x wrote to y))</li>
<li>~ &exist; x (&forall; y (Tyx &rarr; Wxy))</li>
<li>This is a pretty darn solid way to do it.</li>
<li>Also, liberally apply parentheses.</li>
</ul>

<p>
Sally never writes to me.  ~Wsm
</p>

<p>
Sally never writes to anyone: ~ &exist; x Wsx.  Or just &forall; x ~Wsx
</p>

<p>
Need to translate and do trees.  The FOL trees will a bit difficult to learn
in time.
</p>

<p>
List of rules:
</p>
<ul class="org-ul">
<li>Never work inside a sentence when doing a tree.</li>
<li>Never create a constant for a universal (unless there's <b>no other place</b> to
get one).</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline21" class="outline-2">
<h2 id="orgheadline21"><span class="section-number-2">15</span> 2015-11-11 Wednesday</h2>
<div class="outline-text-2" id="text-15">
<p>
The quiz is not today.  Go figure.  It was postponed due to a study group of 8
people who said they weren't ready.  Interesting.  So, we'll do some more
examples.  Maybe I'll get the FOL tree algorithm down.
</p>

<p>
Don't forget universe of discourse.  It's important for statements to have
meaning when you interpret them.  It's less important for logic class, but
still important to have in mind.
</p>

<p>
Vocab:
</p>
<ul class="org-ul">
<li>Gx: x is greek</li>
<li>Px: x is a poet</li>
<li>Mx: x is mortal</li>
</ul>

<p>
Argument:
</p>
<ul class="org-ul">
<li>All Greeks are Poets.</li>
<li>Some Poets are Immortal.</li>
<li>Some Greeks are immortal.</li>
</ul>

<p>
Translation:
</p>
<ul class="org-ul">
<li>&forall; x (Gx &rarr; Px)</li>
<li>&exist; x (Px &and; ~Mx)</li>
<li>&exist; x (Gx &and; ~Mx)</li>
</ul>

<p>
Now the discussion is getting lost in the silly, unimportant details of
translation.
</p>

<p>
Tree:
</p>
<ol class="org-ol">
<li>Start with the second sentence.  Why?  Because that will give us a
constant.  We define \(a\) such that \(Pa \land ~Ma\).</li>
<li>Go to the second sentence.  Now, we apply the universal to \(a\), and get
\(Ga \to Pa\).</li>
<li>Go to the third sentence.  Do the "rotation', and we get a universal, so we
can apply it to \(a\): \(~(Ga \land ~Ma)\).</li>
<li>Now we have checked off all our existentials and applied all our
universals, so we can start doing a SL tree!
<ul class="org-ul">
<li>We have Pa, ~Ma (from the first sentence)
<ul class="org-ul">
<li>~Ga (from third sentence).  If we did the second sentence, we would see
that this branch is left open, so we have a contradiction.</li>
<li>~~Ma (from third sentence) contradiction, so this closes.</li>
</ul></li>
</ul></li>
</ol>

<p>
The contradiction:
</p>
<ul class="org-ul">
<li>UD = {a}</li>
<li>P = {a}</li>
<li>G = &empty;</li>
<li>M = &empty;</li>
</ul>

<p>
Notes on how FOL trees work:
</p>
<ul class="org-ul">
<li>You close a branch when you encounter anything and its negation (i.e. a
contradiction).</li>
<li>You know you have a counter example when everything that can be checked off
(sentences and existentials) has been, and all universals have been applied
to all constants, and there are no contradictions.</li>
<li>You don't check off universals.  You simply mark the substitutions next to
it.</li>
<li>You do check off existentials, once you have created a constant for them.</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Stephen Brennan</p>
<p class="date">Created: 2015-11-23 Mon 16:26</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
